---
title: "Data Project Team GoBills"
author: "STAT 420, Summer 2023, Naveen Baskaran (nc42), Frank Salamone (frankns2), Aleksandr Stpenko(as99)"
date: ''
output:
  html_document:
    theme: readable
    toc: yes
  word_document:
    toc: yes
  pdf_document: default
urlcolor: cyan
---


***

### 1. The names of the students who will be contributing to the group project.

Naveen Baskaran (nc42)
Frank Salamone (frankns2)
Aleksandr Stepenko (as99)

### 2. A tentative title for the project.

“Predicting Airbnb Prices in London on Weekends”

### 3. Description of the data file (what they contain including number of variables and number of records). You do not necessarily have to list all the variables, but at least mention those of greatest importance.

Our dataset concerns Airbnb rentals in London on the weekends.  It contains 19 variables in this dataset with 5379 records. These records consist of information regarding the characteristics of each rental, and the total price of the listing.  Our dataset is a subset of a larger collection of Airbnb listings in many European cities.

The most important variable is realSum, which is the total price of the listing, and will serve as our response.  There are many categorical variables, including, most importantly,  room_type, room_shared, and host_is_superhost.  The distance to city center, dist, and metro_dist, the distance to the nearest metro station, will be important continuous numeric variables.  

### 4. Background information on the data sets, including specific citation of their source (so that I can also access it).

This dataset was found on Kaggle. Briefly, it is a part of a larger set of Airbnb prices in European cities.  Please see the dataset description below (taken from Kaggle).

https://www.kaggle.com/datasets/thedevastator/airbnb-prices-in-european-cities?resource=download

“This dataset provides a comprehensive look at Airbnb prices in some of the most popular European cities. Each listing is evaluated for various attributes such as room types, cleanliness and satisfaction ratings, bedrooms, distance from the city center, and more to capture an in-depth understanding of Airbnb prices on both weekdays and weekends. Using spatial econometric methods, we analyze and identify the determinants of Airbnb prices across these cities. Our dataset includes information such as realSum (the total price of the listing), room_type (private/shared/entire home/apt), host_is_superhost (boolean value indicating if host is a superhost or not), multi (indicator whether listing is for multiple rooms or not), biz (business indicator) , guest_satisfaction_overall (overall rating from guests comparing all listings offered by host ), bedrooms, dist (distance from city center) , lng & lat coordinates for location identification etc. We hope that this data set offers insight into how global markets are affected by social dynamics and geographical factors which in turn determine pricing strategies for optimal profitability!”

### 5. A brief statement of the business, science, research, or personal interest you have in the data set which you hope to explore. 

From an outsider’s perspective, the Airbnb platform has revolutionized the renting of rooms much as Uber has revolutionized ridesharing.  Airbnb allows users of the platform to monetize property that they would not be able to otherwise.  In order to determine if renting out a room is a good business case or worth the owner’s time, it would be helpful to have an estimate of how much income the room would generate.  Our proposal is to develop a model, trained on the London Weekend Airbnb data, that could predict the room rental income based on predictors known to the person putting the room up for rent.  

### 6. Evidence that the data can be loaded into R. Load the data, and print the first few values of the response variable as evidence.

**Solution**

```{r}
london = read.csv("london_weekends.csv")
head(london$realSum)
head(london)
nrow(london)
ncol(london)
```


Methods
First part:
Exploratory analysis.  Lay out what variables look like they are related to the response through correlation
analysis.  Scatterplot matrix.  Basic analysis.  Hint on possibility of collinearity.
Second part:
Some connector between predictors and response in linear fashon.  Main effects analysis.
Aren't completely happy.  Give RMSE, RSE, adjusted r^2.
Next try to remove predictors to increase explanatory power.
Third part:
Try transformations, interactions.  Polynomial terms.
Do backward elimination from your big model from above.
Go in same order as introduced in the course.
Model assumptions
Train and test split

Results
Dont' characterize all models.  2 or 3 or 4models that seem to be the best.  Say why fully additive model
didn't work.  Show progress that you made.  End results.  Hit the highlights.
Discussion
Table with candidate model, with RMSC, residuals, assumptions.  Argue why model is the best.

## Introduction

rubric:  Introduction  Lay everything out in terms of data.  Objective of what want to learn about data.

From an outsider’s perspective, the Airbnb platform has revolutionized the renting of rooms much as Uber has revolutionized ridesharing.  Airbnb allows users of the platform to monetize property that they would not be able to otherwise.  In order to determine if renting out a room is a good business case or worth the owner’s time, it would be helpful to have an estimate of how much income the room would generate.  Our proposal is to develop a model, trained on the London Weekend Airbnb data, that could predict the room rental income based on predictors known to the person putting the room up for rent.  The data is available on Kaggle at https://www.kaggle.com/datasets/thedevastator/airbnb-prices-in-european-cities, and from the original authors, Gyódi, Kristóf and Nawaro, Łukasz at https://zenodo.org/record/4446043#.Y9Y9ENJBwUE.

The columns of the database include:

realSum: the full price of accommodation for two people and two nights in EUR
room_type: the type of the accommodation 
room_shared: dummy variable for shared rooms
room_private: dummy variable for private rooms
person_capacity: the maximum number of guests 
host_is_superhost: dummy variable for superhost status
multi: dummy variable if the listing belongs to hosts with 2-4 offers
biz: dummy variable if the listing belongs to hosts with more than 4 offers
cleanliness_rating: cleanliness rating
guest_satisfaction_overall: overall rating of the listing
bedrooms: number of bedrooms (0 for studios)
dist: distance from city centre in km
metro_dist: distance from nearest metro station in km
attr_index: attraction index of the listing location
attr_index_norm: normalised attraction index (0-100)
rest_index: restaurant index of the listing location
attr_index_norm: normalised restaurant index (0-100)
lng: longitude of the listing location
lat: latitude of the listing location

What are the dimensions of the dataset?

```{r}
nrow(london)
ncol(london)
```

There are 5379 rows of data with 20 variables, as described above.

## Methods

Rubric:
Methods
First part:
Exploratory analysis.  Lay out what variables look like they are related to the response through correlation
analysis.  Scatterplot matrix.  Basic analysis.  Hint on possibility of collinearity.
Second part:
Some connector between predictors and response in linear fashon.  Main effects analysis.
Aren't completely happy.  Give RMSE, RSE, adjusted r^2.
Next try to remove predictors to increase explanatory power.
Third part:
Try transformations, interactions.  Polynomial terms.
Do backward elimination from your big model from above.
Go in same order as introduced in the course.


### Data Cleaning

There are several variables that need to be converted to factors.  These include: room_type, room_shared, room_private, and host_is_superhost.  

```{r}
unique(london$room_type) 
unique(london$room_shared)
unique(london$room_private)
unique(london$host_is_superhost)
```

The room_type column can converted into a 3 level factor variable with the levels being: "Private room", "Entire home/apt", and "Shared room".

Another question is if room_shared and room_private are independent.

```{r}
mean(london$room_shared == london$room_private)
```

Based on the data, they mean different things.

Columns multi and biz are factors stored as integers.

```{r}
unique(london$multi)
unique(london$biz)
```

Switch these to True and False.

```{r}
london$multi[london$multi == 0] = "False"
london$multi[london$multi == 1] = "True"
london$biz[london$biz == 0] = "False"
london$biz[london$biz == 1] = "True"
```

The bedrooms and person_capacity column should also be changed to a factor.

```{r}
unique(london$bedrooms)
unique(london$person_capacity)
```

Switch all to factors, also keep a copy of london with bedrooms and person_capacity as integers 

```{r}
london$room_type = as.factor(london$room_type)
london$room_shared = as.factor(london$room_shared)
london$room_private = as.factor(london$room_private)
london$multi = as.factor(london$multi)
london$biz = as.factor(london$biz)
london$host_is_superhost = as.factor(london$host_is_superhost)
london_less_factors = london
london$person_capacity = as.factor(london$person_capacity)
london$bedrooms = as.factor(london$bedrooms)
head(london)
head(london_less_factors)
```

Variables attr_index and attr_index_norm will be collinear, as will rest_index and rest_index_norm, so the non-normalized columns are removed from the dataframe.  Also, on initial analysis of linear models, it was apparent that room_shared and room_private are exactly collinear with room_type, so they will be removed.  Also, remove the index X

```{r}
cor(london$attr_index, london$attr_index_norm)
cor(london$rest_index, london$rest_index_norm)
london = subset(london, select = -c(attr_index, rest_index, room_shared, room_private, X))
london_less_factors = subset(london_less_factors, select = -c(attr_index, rest_index, room_shared, room_private, X))
```


See if there are any NAs:

```{r}
sum(is.na(london))
```

```{r}
head(london)
head(london_less_factors)
```


### Exploratory Analysis

#### Main Effects Analysis

```{r}
full_additive_mod = lm(realSum ~ ., data = london)
summary(full_additive_mod)
```
Fitting an additive model with no interactions to the data yields an $R^2 = 0.2769$.  This seems quite low.  

Bedrooms and person_capacity have a large number of values, maybe a model with them as numbers, not factors would give a better fit.

```{r}
full_additive_less_factors_mod = lm(realSum ~ ., data = london_less_factors)
summary(full_additive_less_factors_mod)
```
Using bedrooms and person_capacity gives a slightly worse $R^2 = 0.2581$, as compared to $R^2 = 0.2769$ as factors.

We will use AIC to determine if any of the predictors can be dropped.

```{r}
aic_full_additive_mod = step(full_additive_mod, direction = "backward", trace = FALSE)
summary(aic_full_additive_mod)
```
AIC eliminates just host_is_superhostTrue, multiTrue, bizTrue, cleanliness_rating, rest_index_norm, and lat.  The $R^2$ value of this model left after AIC elimination is almost the same at 0.2768 as compared to the full additive model with an $R^2$ of 0.2769. 

We will now try BIC to see if this results in a smaller model.

```{r}
bic_full_additive_mod = step(full_additive_mod, direction = "backward", k = log(nrow(london)), trace = FALSE)
summary(bic_full_additive_mod)
```

BIC, as we would expect, produces a smaller model.

We will now use ANOVA to see if there is any significant difference between the models explored in this main effects analysis.

```{r}
anova(aic_full_additive_mod, full_additive_mod)
anova(bic_full_additive_mod, full_additive_mod)
```

So, we reject the null hypothesis with regards to the model obtained with BIC, and choose the model obtained through AIC elimination.  The $R^2$ value is still quite low with just an additive model.

As there is little difference between these models, we will continue the analysis with the full linear model.

#### Collinearity Analysis

Although collinearity likely will not affect prediction, it will affect our ability to perform inference tests.

```{r}
london_numeric = subset(london, select = c(cleanliness_rating, guest_satisfaction_overall, dist, metro_dist, attr_index_norm, rest_index_norm))
pairs(london_numeric)
```

Some of these data show collinearity and some look non-linear.  In particular, distance and metro_distance seem to be collinear.

Let us check for collinearity using the variance inflation factor.

```{r}
library(faraway)
vif(full_additive_mod)
vif(full_additive_mod)[unname(vif(full_additive_mod)) > 5]
``` 

Per the textbook, predictors with a VIF of more than 5 are suspicious for collinearity.  The variables with VIF values more than 5 include dist, attr_index_norm, and rest_index_norm. This makes sense as dist is the distance to the city center, and it is likely that if this is small, the number of attractions and restaurants (as measured by attr_index_norm and rest_index_norm) would be high.  There are more attractions and restaurants near the city center.  Also, metro_dist, the distance to a metro station, would likely be small if dist is small. These values are not tremendously larger than 5, so we will keep them in model.

#### Transformation Analysis

What does the distribution of the room prices look like?

```{r}
hist(london$realSum)
```

Maybe this would look better if we took the logarithm.  This is a typical transformation for prices that can vary over several orders of magnitude.  

```{r}
hist(log(london$realSum))
```

This does look much better.  Let us try to fit a model with the log transformation of the response.

```{r}
full_log_model = lm(log(realSum) ~ ., data = london)
summary(full_log_model)
```
The log transformation gives a much better $R^2$.  The $R^2$ value increased from around 0.27 to 0.6878 with the log transform.

How is this better in terms of RMSE?

```{r}
sqrt(mean(full_log_model$residuals^2))
sqrt(mean(full_additive_mod$residuals^2))
```

The log model also has much lower RMSE.

Try transformations of other variables.

```{r}
hist(london$rest_index_norm)
```

```{r}
hist(log(london$rest_index_norm))
```

```{r}
hist(sqrt(london$dist))
```

Maybe transformations of other variables may be of help.

```{r}
print("Baseline R^2 value for the full additive log model with all predictors and log transformation of the response realSum")
summary(full_log_model)$r.squared

print("R^2 Values")
print("Transformations of dist")
summary(lm(log(realSum) ~ . - dist + I(dist^2), data = london))$r.squared
summary(lm(log(realSum) ~ . - dist + I(dist^3), data = london))$r.squared
summary(lm(log(realSum) ~ . - dist + I(1/dist), data = london))$r.squared
summary(lm(log(realSum) ~ . - dist + log1p(dist), data = london))$r.squared

print("Transformations of metro_dist")
summary(lm(log(realSum) ~ . - metro_dist + I(metro_dist^2), data = london))$r.squared
summary(lm(log(realSum) ~ . - metro_dist + I(metro_dist^3), data = london))$r.squared
summary(lm(log(realSum) ~ . - metro_dist + I(1/metro_dist), data = london))$r.squared
summary(lm(log(realSum) ~ . - metro_dist + log1p(metro_dist), data = london))$r.squared

print("Transformations of cleanliness_rating")
summary(lm(log(realSum) ~ . - cleanliness_rating + I(cleanliness_rating^2), data = london))$r.squared
summary(lm(log(realSum) ~ . - cleanliness_rating + I(cleanliness_rating^3), data = london))$r.squared
summary(lm(log(realSum) ~ . - cleanliness_rating + I(1/cleanliness_rating), data = london))$r.squared
summary(lm(log(realSum) ~ . - cleanliness_rating + log1p(cleanliness_rating), data = london))$r.squared

print("Transformations of guest_satisfaction_overall")
summary(lm(log(realSum) ~ . - guest_satisfaction_overall + I(guest_satisfaction_overall^2), data = london))$r.squared
summary(lm(log(realSum) ~ . - guest_satisfaction_overall + I(guest_satisfaction_overall^3), data = london))$r.squared
summary(lm(log(realSum) ~ . - guest_satisfaction_overall + I(1/guest_satisfaction_overall), data = london))$r.squared
summary(lm(log(realSum) ~ . - guest_satisfaction_overall + log1p(guest_satisfaction_overall), data = london))$r.squared

print("Transformations of attr_index_norm")
summary(lm(log(realSum) ~ . - attr_index_norm + I(attr_index_norm^2), data = london))$r.squared
summary(lm(log(realSum) ~ . - attr_index_norm + I(attr_index_norm^3), data = london))$r.squared
summary(lm(log(realSum) ~ . - attr_index_norm + I(1/attr_index_norm), data = london))$r.squared
summary(lm(log(realSum) ~ . - attr_index_norm + log1p(attr_index_norm), data = london))$r.squared

print("Transformations of rest_index_norm")
summary(lm(log(realSum) ~ . - rest_index_norm + I(rest_index_norm^2), data = london))$r.squared
summary(lm(log(realSum) ~ . - rest_index_norm + I(rest_index_norm^3), data = london))$r.squared
summary(lm(log(realSum) ~ . - rest_index_norm + I(1/rest_index_norm), data = london))$r.squared
summary(lm(log(realSum) ~ . - rest_index_norm + log1p(rest_index_norm), data = london))$r.squared

print("Transformations of lat")
summary(lm(log(realSum) ~ . - lat + I(lat^2), data = london))$r.squared
summary(lm(log(realSum) ~ . - lat + I(lat^3), data = london))$r.squared
summary(lm(log(realSum) ~ . - lat + I(1/lat), data = london))$r.squared
summary(lm(log(realSum) ~ . - lat + log1p(lat), data = london))$r.squared

print("Transformations of lng")
summary(lm(log(realSum) ~ . - lng + I(lng^2), data = london))$r.squared
summary(lm(log(realSum) ~ . - lng + I(lng^3), data = london))$r.squared
summary(lm(log(realSum) ~ . - lng + I(1/lng), data = london))$r.squared
summary(lm(log(realSum) ~ . - lng + log1p(lng), data = london))$r.squared

```

The biggest improvement in terms of $R^2$ seems to be with 1/rest_index_norm.

How do these do in terms of RMSE?

```{r}
sqrt(mean(full_log_model$residuals^2))
sqrt(mean(lm(log(realSum) ~ . - rest_index_norm + I(1/rest_index_norm), data = london)$residuals^2))
```

1/rest_index_norm also has lower RMSE.

#### Interaction Analysis

Next do a model with interactions, and then reduce the number of variables with backward AIC.  We will start with the full log model.

```{r}
full_interact = lm(log(realSum) ~ .^2, data = london)
summary(full_interact)$r.squared
```

The full interaction model has a higher $R^2$ value than any of the transformation models above.  We will have to check if there is overfitting.

```{r}
sqrt(mean(full_interact$residuals^2))
```

The full_interact model has a lower RMSE than the transformation models.

The full interaction model is quite large.  Let us use AIC and BIC to reduce the number of predictors.

```{r}
aic_full_interact = step (full_interact, direction = "backward", trace = FALSE)
```


```{r}
nrow(summary(full_interact)$coeff)
nrow(summary(aic_full_interact)$coeff)
summary(aic_full_interact)$r.squared
```

AIC decreases the number of coefficients from 214 in the full interaction model to 113 with a decrease in $R^2$ from 0.7335292 to 0.7294467.

Try BIC to get a smaller model

```{r}
bic_full_interact = step (full_interact, direction = "backward", trace = FALSE, k = log(nrow(london)))
```

```{r}
nrow(summary(full_interact)$coeff)
nrow(summary(bic_full_interact)$coeff)
summary(bic_full_interact)$r.squared
```

BIC decreases the number of coefficients from 214 in the full interaction model to 45 with a decrease in $R^2$ from 0.7335292 to 0.7171065.

#### Putting It Together

Try a model with transformations and interactions.  Start with the model from the BIC elimination above and add the 1/rest_index_norm transformation.

```{r}
combined_model =  lm(log(realSum) ~ room_type + person_capacity + multi + biz + cleanliness_rating + guest_satisfaction_overall
                     + bedrooms + dist + metro_dist + attr_index_norm  + lng + lat
                     + multi:guest_satisfaction_overall + biz:cleanliness_rating                     
                     + cleanliness_rating:guest_satisfaction_overall                        
                     + dist:metro_dist + dist:rest_index_norm + metro_dist:attr_index_norm + metro_dist:rest_index_norm
                     + I(1/rest_index_norm), data = london)

nrow(summary(combined_model)$coeff)
summary(combined_model)$r.squared
```


```{r}
bic_combined = step (combined_model, direction = "backward", trace = FALSE, k = log(nrow(london)))

summary(bic_combined)

vif(bic_combined)
```


Let us remove predictors to increase explanatory power.

```{r}
smaller_combined_model =  lm(log(realSum) ~ room_type + person_capacity + cleanliness_rating + guest_satisfaction_overall
                     + bedrooms + dist + attr_index_norm  + lng + lat
                     + multi:guest_satisfaction_overall + biz:cleanliness_rating                     
                     + cleanliness_rating:guest_satisfaction_overall                        
                     + dist:metro_dist + dist:rest_index_norm + metro_dist:attr_index_norm, data = london)

vif(smaller_combined_model)
summary(smaller_combined_model)
summary(smaller_combined_model)$r.squared
```

```{r}
anova(smaller_combined_model, combined_model)
anova(combined_model, full_interact)
```



```{r}

#anova(smaller_combined_model, combined_model)
#anova(combined_model, full_interact)
calc_loocv_rmse = function(model) {
  sqrt(mean((resid(model) / (1 - hatvalues(model))) ^ 2))
}

calc_loocv_rmse(full_additive_mod)
```

```{r}
require(caret)
require(dplyr)
require(tidyverse)

### Data splitting: leave one out
train.loocv <- trainControl(method = "LOOCV")

### Training
model.loocv <- train(log(realSum) ~ room_type + person_capacity + cleanliness_rating + guest_satisfaction_overall
                     + bedrooms + dist + attr_index_norm  + lng + lat
                     + multi:guest_satisfaction_overall + biz:cleanliness_rating                     
                     + cleanliness_rating:guest_satisfaction_overall                        
                     + dist:metro_dist + dist:rest_index_norm + metro_dist:attr_index_norm, data = london,
                     method = "lm",
                     trControl = train.loocv)

### Present results
print(model.loocv)

```

```{r}
### Data splitting: leave one out
train.loocv <- trainControl(method = "LOOCV")

### Training
model.loocv <- train(log(realSum) ~ .^2, data = london,
                     method = "lm",
                     trControl = train.loocv)

### Present results
print(model.loocv)

```




























Try bedrooms and person_capacity as numbers, not factors.

```{r}
full_less_factors = lm(log(realSum) ~ (.  - room_shared - room_private)^2, data = london_less_factors)
summary(full_less_factors)
```
Having the variables as factors gives a better fit.  The R^2 value for the models using factors is 0.7304, while it is 0.7222 for the numeric.  I will continue to use factor model. 

```{r}
summary(mod)
```

Try a smaller model

```{r}
smaller = lm(log(realSum) ~ room_type + person_capacity + cleanliness_rating + dist + rest_index_norm + person_capacity:bedrooms + attr_index_norm:rest_index_norm , data = london_less_factors)
summary(smaller)
```

Try transformations of other variables

```{r}
hist(london$rest_index_norm)
```

```{r}
hist(log(london$rest_index_norm))
```

We can try a transformation of rest_index_norm

```{r}
smaller_log = lm(log(realSum) ~ room_type + person_capacity + dist + log1p(rest_index_norm) + cleanliness_rating:guest_satisfaction_overall  + person_capacity:bedrooms + attr_index_norm:rest_index_norm , data = london_less_factors)
summary(smaller_log)
```

Try forward BIC

```{r}
full_interact_less_fact = lm(log(realSum) ~ (. - room_shared - room_private)^2, data = london_less_factors)
bic_mod = step(smaller_log, scope = log(realSum) ~ .^2, k = log(nrow(london_less_factors)), trace = FALSE)
bic_mod
```


```{r}
summary(bic_mod)
```

```{r}
bic_mod_fact = lm(formula = log(realSum) ~ room_type + person_capacity + dist + 
    log1p(rest_index_norm) + cleanliness_rating:guest_satisfaction_overall + 
    person_capacity:bedrooms + attr_index_norm:rest_index_norm + 
    dist:log1p(rest_index_norm) + room_type:person_capacity + 
    log1p(rest_index_norm):cleanliness_rating:guest_satisfaction_overall + 
    log1p(rest_index_norm):attr_index_norm:rest_index_norm + 
    room_type:cleanliness_rating:guest_satisfaction_overall + 
    room_type:person_capacity:bedrooms + dist:attr_index_norm:rest_index_norm, 
    data = london)
summary(bic_mod_fact)
```
Another smaller model attempt:

```{r}
attempt2 = lm(log(realSum) ~ room_type + person_capacity + dist + 
    log1p(rest_index_norm) + cleanliness_rating:guest_satisfaction_overall + 
    person_capacity:bedrooms + attr_index_norm:rest_index_norm + 
    dist:log1p(rest_index_norm) + room_type:person_capacity + 
    log1p(rest_index_norm):cleanliness_rating:guest_satisfaction_overall + 
    log1p(rest_index_norm):attr_index_norm:rest_index_norm + 
    room_type:cleanliness_rating:guest_satisfaction_overall + dist:attr_index_norm:rest_index_norm, 
    data = london)
summary(attempt2)
```

```{r}

```


######Check if overfiit


***

